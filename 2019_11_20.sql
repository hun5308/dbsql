--1. DESC 테이블명
--2 SELECT user_tab_colums;

--prod 테이블의 컬럼조회

DESC prod;

VARCHAR2, CHAR -> 문자열(character)
NUMBER -> 숫자
CLOB -> charactar large OBject, 문자영 타입의 길이 제한을 피하는 타입
  --최대 사이즈 : VARCHAR2(4000),  CLOB : 4GB
  
  DATA -> 날짜 (일시 = 년, 월, 일 + 시간, 분, 초)
  
  --date 타입에 대한 션산의 결과는?
  '2019/11/20 09:16:20' + 1 = ?
  
  --USERS 테이블의 모든 컬럼을 조회해 보세요
SELECT *
FROM users;

--userid, usernm, reg_dt 세가지 컬럼만 조회
SELECT userid, usernm, reg_dt
FROM users;

--연산을 통해 새로운 컬럼으 ㄹ생성 (reg_dt에 숫자연산을 한 새로운 가공 컬럼)
-- 날짜 + 정수 연산 ==> 일자를 더한 날짜타입이 결과로 나온다
-- 별칭 : 기존 걸럼명이나 연산을 통해 생성된 가상 컬럼에 임의의 컬럼이름을 부여
-- col 이나 express [AS] 별칭명
SELECT userid, usernm, reg_dt , reg_dt+5 after5day
FROM users;

--숫자 상수, 문자열 상수 (orale: '' , java : '',"")
--table에 없는 값을 임으로 컬럼으로 생성
--숫자에 대한 연산 ( +, -, /, *)
--문자에 대한 연산(+가 존재하지 않음, ==> ||)
SELECT (10-2)*2, 'DE SQL 수업',  
/*userid + 'modified',문자열 연산은 더하기 연산이 없다*/
        usernm ||'_modified', reg_dt
FROM users;


--NULL : 아직 모르는 값
--NULL에 대한 연산 결과는 항상 NULL이다
--DESC 테이블명 : NOT NULL로 설정 되어있는 컬럼에는 값이 반드시 들어가야 한다


--user 불필요한 데이터 삭제
SELECT *
FROM users;


DELETE users
WHERE userid NOT IN ('brown', 'sally', 'cony', 'moon', 'james');

rollback;

commit;

SELECT userid, reg_dt
FROM users;
--null 현산을 시험해보기 위해 moon의 reg_dt 컬럼을 null로 변경
UPDATE users SET reg_dt = NULL
WHERE userid = 'moon';

ROLLBACK;
COMMIT;

--users 테이블의 reg_dt 컬럼값에 5일을 더한 새로운 컬럼을 생성
SELECT userid, usernm, reg_dt, reg_dt+5
FROM users;

--실습 select2
--prod 테이블에서 prod_id, prod_name 두 컬럼을 조회하는 쿼리를 작성하시오 (단 prod_id -> id, prod_name -> name 으로 컬럼 별칭을 지정)
SELECT prod_id id, prod_name name
FROM prod;
--lprod 테이블에서 lprod_gu, lprod_nm 두 컬럼을 조회하는 쿼리를 작성하시오.(단 lprod_gu -> gu, lprod_nm -> nm으로 컬럼 별칭을 지정)
SELECT lprod_gu gu, lprod_nm nm
FROM lprod;
--buyer 테이블에서 buyer_id, buyer_name 두 컬럼을 조회하는 쿼리를 작성하시오.(단 buyer_id -> 바이어아이디, buyer_name ->이름 으로 컬럼 별칭을 지정)
SELECT buyer_id 바이어아이디 , buyer_name 이름
FROM buyer;



--문자열 컬럼간 결합   (컬럼 || 컬럼, '문자열상수' || 컬럼), (CONCAT(컬럼, 컬럼)
SELECT userid, usernm,
       userid || usernm AS id_nm,
       CONCAT(userid, usernm) con_id_nm,
       --||을 이용해서 userid, usernm, pass
       userid || usernm || pass id_nm_pass,
       --CONCAT을 이용해서 userid, usernm, pass
       CONCAT(CONCAT(userid, usernm), pass) con_id_nm_pass
FROM users;

--사용자가 소유한 테이블 목록 조회
SELECT 'SELECT * FROM '|| table_name||';' query 
--CONCAT 함수만 이용해서
--1.'SELECT * FROM'
--2. table_name
--3. ';'
    --CONCAT('SELECT * FROM ',CONCAT(table_name,';')) query
FROM user_tables;



--WHERE : 조건이 일치하는 형만 조회하기위해 사용
--      행에 대한 조회 기준을 작성
SELECT userid, usernm, alias, reg_dt
FROM users
WHERE userid = 'brown';--userid 컬럼이 'brown'인 행(row)만 조회   

--emp테이블의 전체 데이터 조회 (모든행(row), 열(colum))
SELECT *
FROM emp

--부서번호(DEPTNO)가 20보다 크거나 같은 부서에서 일하는 직원 정보 조회
--WHERE deptno >= 20

--사원번호가(empno) 7700보다 크거나 같은 사원의 정보를 조회
WHERE empno >= 7700;


--사원 입사일자가 1982년 1월 1일 이후인 사원 정보 조회
--문자열 --> 날짜 타입으로 변경 TO_DATE('날짜문자열', '날짜문자열포맷')
--한국 날짜 표현 : --년 --월 --일 (2020-01-01)
--미국 날짜 표현 : --일 --월 --년 (01-01-2020)
SELECT empno, ename, hiredate,
       2000 no, '문자열상수' str, TO_DATE('19810101', 'yyyymmdd')
FROM emp
WHERE hiredate >= TO_DATE('19820101', 'yyyymmdd');

--범위조회 (BETWEEN 시작기준 AND 종료기준)
--시작기준, 종료기준을 포함
--사원중에서 급여(Sal)가 1000보다 크거나 같고, 2000보다 작거나 같은 사원정보 조회
SELECT *
FROM emp
WHERE sal BETWEEN 1000 AND 2000;

--BETWEEN AND 연산자는 부등호 연산자로 대체 가능
SELECT *
FROM emp
WHERE sal >= 1000 AND sal <= 2000;

--emp 테이블에서 입사일자가 1982년 1월1일 이후부터 1983년 1월 1일 이전인 사원듸 ename, hiredate 데이터를 조회하는 쿼리를 작성하시오
--(단 연산자는 between을 사용한다)
SELECT ename, hiredate
FROM emp
WHERE hiredate BETWEEN TO_DATE('19820101', 'yyyymmdd') AND TO_DATE('19830101', 'yyyymmdd');

--동일한 문제에 비교 연산자를 사용하라
SELECT ename, TO_CHAR (hiredate, 'yyyy-mm-dd')
FROM emp
WHERE hiredate >= TO_DATE('19820101', 'yyyymmdd') AND hiredate <= TO_DATE('19830101', 'yyyymmdd');